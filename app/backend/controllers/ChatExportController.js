// ChatExportController.js - Message export functionality (Markdown, TXT, DOCX)
const { Document, Paragraph, TextRun, HeadingLevel, Packer, AlignmentType, BorderStyle } = require('docx');

class ChatExportController {
    constructor(chatStorage) {
        this.chatStorage = chatStorage;
    }

    // Download message in various formats
    async downloadMessage(req, res) {
        try {
            // Parse JSON body manually
            let bodyData = '';
            req.on('data', chunk => bodyData += chunk);
            await new Promise(resolve => req.on('end', resolve));

            const body = JSON.parse(bodyData);
            const { chatId, messageTimestamp, format = 'markdown' } = body;

            console.log('ðŸ“¥ Download message request:', { chatId, messageTimestamp, format });

            if (!chatId || !messageTimestamp) {
                res.writeHead(400, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Missing chatId or messageTimestamp' }));
                return;
            }

            // Load chat messages
            const chat = this.chatStorage.loadChat(chatId);
            console.log('ðŸ“‹ Chat loaded:', { success: chat.success, hasMessages: !!chat.messages });

            if (!chat.success) {
                res.writeHead(404, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Chat not found' }));
                return;
            }

            // Structure is {success, chatId, metadata, messages} not {success, data}
            const messages = chat.messages || [];
            console.log('ðŸ“‹ Looking for timestamp:', messageTimestamp);
            console.log('ðŸ“‹ Available timestamps:', messages.map(m => m.timestamp));

            const message = messages.find(m => m.timestamp === messageTimestamp);
            console.log('ðŸ“‹ Message found:', !!message);

            if (!message) {
                res.writeHead(404, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({
                    error: 'Message not found',
                    requested: messageTimestamp,
                    available: messages.map(m => m.timestamp)
                }));
                return;
            }

            // Generate content in requested format
            let content, mimeType, extension;

            switch (format) {
                case 'markdown':
                    content = this._generateMarkdown(message, chat.metadata);
                    mimeType = 'text/markdown';
                    extension = 'md';
                    break;

                case 'txt':
                    content = this._generateTXT(message, chat.metadata);
                    mimeType = 'text/plain';
                    extension = 'txt';
                    break;

                case 'pdf':
                    content = this._generateTXT(message, chat.metadata);
                    mimeType = 'text/plain';
                    extension = 'txt';
                    break;

                case 'docx':
                    content = await this._generateDocx(message, chat.metadata);
                    mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                    extension = 'docx';
                    break;

                default:
                    res.writeHead(400, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Unsupported format' }));
                    return;
            }

            const filename = `message_${messageTimestamp}.${extension}`;

            // Handle both Buffer (DOCX) and string (other formats)
            const contentLength = Buffer.isBuffer(content) ? content.length : Buffer.byteLength(content);

            res.writeHead(200, {
                'Content-Type': mimeType,
                'Content-Disposition': `attachment; filename="${filename}"`,
                'Content-Length': contentLength
            });
            res.end(content);

            console.log('âœ… Message downloaded successfully:', filename);

        } catch (error) {
            console.error('âŒ Download message error:', error);
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Download failed', details: error.message }));
        }
    }

    // Generate Markdown format
    _generateMarkdown(message, metadata) {
        const timestamp = new Date(message.timestamp).toLocaleString();
        const chatTitle = metadata?.title || 'Conversation';
        const model = metadata?.model || 'Unknown';

        return `# ${chatTitle}

**Date**: ${timestamp}
**Model**: ${model}
**Role**: ${message.role}

---

${message.content}

---
*Generated by Ollama Easy GUI*`;
    }

    // Generate TXT format (simple and reliable)
    _generateTXT(message, metadata) {
        const timestamp = new Date(message.timestamp).toLocaleString();
        const chatTitle = metadata?.title || 'Conversation';
        const model = metadata?.model || 'Unknown';

        return `========================================
Ollama Easy GUI - Message Export
========================================

Chat: ${chatTitle}
Date: ${timestamp}
Model: ${model}
Role: ${message.role}

----------------------------------------
CONTENT:
----------------------------------------

${message.content}

----------------------------------------
Generated by Ollama Easy GUI
========================================`;
    }

    // Generate DOCX format using docx library
    async _generateDocx(message, metadata) {
        const timestamp = new Date(message.timestamp).toLocaleString();
        const chatTitle = metadata?.title || 'Conversation';
        const model = metadata?.model || 'Unknown';

        // Parse markdown content into paragraphs
        const contentParagraphs = this._parseContentToParagraphs(message.content);

        const doc = new Document({
            title: chatTitle,
            description: `Exported from Ollama Easy GUI - ${timestamp}`,
            creator: 'Ollama Easy GUI',
            sections: [{
                properties: {},
                children: [
                    // Title
                    new Paragraph({
                        text: chatTitle,
                        heading: HeadingLevel.TITLE,
                        alignment: AlignmentType.CENTER,
                        spacing: { after: 200 }
                    }),

                    // Metadata section
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Date: ', bold: true }),
                            new TextRun(timestamp)
                        ],
                        spacing: { after: 100 }
                    }),
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Model: ', bold: true }),
                            new TextRun(model)
                        ],
                        spacing: { after: 100 }
                    }),
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Role: ', bold: true }),
                            new TextRun(message.role)
                        ],
                        spacing: { after: 200 }
                    }),

                    // Separator
                    new Paragraph({
                        text: '',
                        border: {
                            bottom: { style: BorderStyle.SINGLE, size: 6, color: 'CCCCCC' }
                        },
                        spacing: { after: 200 }
                    }),

                    // Content paragraphs
                    ...contentParagraphs,

                    // Footer separator
                    new Paragraph({
                        text: '',
                        border: {
                            bottom: { style: BorderStyle.SINGLE, size: 6, color: 'CCCCCC' }
                        },
                        spacing: { before: 400, after: 200 }
                    }),

                    // Footer
                    new Paragraph({
                        children: [
                            new TextRun({ text: 'Generated by Ollama Easy GUI', italics: true, size: 20 })
                        ],
                        alignment: AlignmentType.CENTER
                    })
                ]
            }]
        });

        // Generate DOCX buffer
        const buffer = await Packer.toBuffer(doc);
        return buffer;
    }

    // Parse message content into DOCX paragraphs (handles basic markdown)
    _parseContentToParagraphs(content) {
        const paragraphs = [];
        const lines = content.split('\n');

        for (const line of lines) {
            const trimmed = line.trim();

            // Skip empty lines but add spacing
            if (!trimmed) {
                paragraphs.push(new Paragraph({ text: '', spacing: { after: 100 } }));
                continue;
            }

            // Handle headings
            if (trimmed.startsWith('### ')) {
                paragraphs.push(new Paragraph({
                    text: trimmed.substring(4),
                    heading: HeadingLevel.HEADING_3,
                    spacing: { before: 200, after: 100 }
                }));
            } else if (trimmed.startsWith('## ')) {
                paragraphs.push(new Paragraph({
                    text: trimmed.substring(3),
                    heading: HeadingLevel.HEADING_2,
                    spacing: { before: 200, after: 100 }
                }));
            } else if (trimmed.startsWith('# ')) {
                paragraphs.push(new Paragraph({
                    text: trimmed.substring(2),
                    heading: HeadingLevel.HEADING_1,
                    spacing: { before: 200, after: 100 }
                }));
            }
            // Handle bullet points
            else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
                paragraphs.push(new Paragraph({
                    children: this._parseInlineFormatting(trimmed.substring(2)),
                    bullet: { level: 0 },
                    spacing: { after: 50 }
                }));
            }
            // Handle numbered lists
            else if (/^\d+\.\s/.test(trimmed)) {
                const textContent = trimmed.replace(/^\d+\.\s/, '');
                paragraphs.push(new Paragraph({
                    children: this._parseInlineFormatting(textContent),
                    numbering: { reference: 'default-numbering', level: 0 },
                    spacing: { after: 50 }
                }));
            }
            // Regular paragraph
            else {
                paragraphs.push(new Paragraph({
                    children: this._parseInlineFormatting(trimmed),
                    spacing: { after: 100 }
                }));
            }
        }

        return paragraphs;
    }

    // Parse inline markdown formatting (bold, italic, code)
    _parseInlineFormatting(text) {
        const segments = [];
        let lastIndex = 0;
        let match;

        // Find all bold segments
        const boldRegex = /\*\*(.+?)\*\*/g;
        while ((match = boldRegex.exec(text)) !== null) {
            if (match.index > lastIndex) {
                segments.push({ text: text.substring(lastIndex, match.index), style: {} });
            }
            segments.push({ text: match[1], style: { bold: true } });
            lastIndex = match.index + match[0].length;
        }

        // If no bold found, check for other formatting
        if (segments.length === 0) {
            // Check for italic
            const italicRegex = /\*(.+?)\*/g;
            lastIndex = 0;
            while ((match = italicRegex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    segments.push({ text: text.substring(lastIndex, match.index), style: {} });
                }
                segments.push({ text: match[1], style: { italics: true } });
                lastIndex = match.index + match[0].length;
            }
        }

        // If still no formatting found, check for code
        if (segments.length === 0) {
            const codeRegex = /`(.+?)`/g;
            lastIndex = 0;
            while ((match = codeRegex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    segments.push({ text: text.substring(lastIndex, match.index), style: {} });
                }
                segments.push({ text: match[1], style: { font: 'Courier New' } });
                lastIndex = match.index + match[0].length;
            }
        }

        // Add remaining text
        if (segments.length > 0 && lastIndex < text.length) {
            segments.push({ text: text.substring(lastIndex), style: {} });
        }

        // If no formatting was found, return plain text
        if (segments.length === 0) {
            return [new TextRun(text)];
        }

        // Convert segments to TextRuns
        return segments.map(seg => new TextRun({ text: seg.text, ...seg.style }));
    }
}

module.exports = ChatExportController;
